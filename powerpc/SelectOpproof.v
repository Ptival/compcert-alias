(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(** Correctness of instruction selection for operators *)

Require Import Coqlib.
Require Import Maps.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Cminor.
Require Import Op.
Require Import CminorSel.
Require Import SelectOp.

Open Local Scope cminorsel_scope.

Section CMCONSTR.

Variable ge: genv.
Variable sp: val.
Variable e: env.
Variable m: mem.

(** * Useful lemmas and tactics *)

(** The following are trivial lemmas and custom tactics that help
  perform backward (inversion) and forward reasoning over the evaluation
  of operator applications. *)  

Ltac EvalOp := eapply eval_Eop; eauto with evalexpr.

Ltac InvEval1 :=
  match goal with
  | [ H: (eval_expr _ _ _ _ _ (Eop _ Enil) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_expr _ _ _ _ _ (Eop _ (_ ::: Enil)) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_expr _ _ _ _ _ (Eop _ (_ ::: _ ::: Enil)) _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_exprlist _ _ _ _ _ Enil _) |- _ ] =>
      inv H; InvEval1
  | [ H: (eval_exprlist _ _ _ _ _ (_ ::: _) _) |- _ ] =>
      inv H; InvEval1
  | _ =>
      idtac
  end.

Ltac InvEval2 :=
  match goal with
  | [ H: (eval_operation _ _ _ nil _ = Some _) |- _ ] =>
      simpl in H; inv H
  | [ H: (eval_operation _ _ _ (_ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | [ H: (eval_operation _ _ _ (_ :: _ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | [ H: (eval_operation _ _ _ (_ :: _ :: _ :: nil) _ = Some _) |- _ ] =>
      simpl in H; FuncInv
  | _ =>
      idtac
  end.

Ltac InvEval := InvEval1; InvEval2; InvEval2.

Ltac TrivialExists :=
  match goal with
  | [ |- exists v, _ /\ Val.lessdef ?a v ] => exists a; split; [EvalOp | auto]
  end.

(** * Correctness of the smart constructors *)

(** We now show that the code generated by "smart constructor" functions
  such as [SelectOp.notint] behaves as expected.  Continuing the
  [notint] example, we show that if the expression [e]
  evaluates to some value [v], then [SelectOp.notint e]
  evaluates to a value [v'] which is either [Val.notint v] or more defined
  than [Val.notint v].

  All proofs follow a common pattern:
- Reasoning by case over the result of the classification functions
  (such as [add_match] for integer addition), gathering additional
  information on the shape of the argument expressions in the non-default
  cases.
- Inversion of the evaluations of the arguments, exploiting the additional
  information thus gathered.
- Equational reasoning over the arithmetic operations performed,
  using the lemmas from the [Int], [Float] and [Value] modules.
- Construction of an evaluation derivation for the expression returned
  by the smart constructor.
*)

Definition unary_constructor_sound (cstr: expr -> expr) (sem: val -> val) : Prop :=
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (cstr a) v /\ Val.lessdef (sem x) v.

Definition binary_constructor_sound (cstr: expr -> expr -> expr) (sem: val -> val -> val) : Prop :=
  forall le a x b y,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  exists v, eval_expr ge sp e m le (cstr a b) v /\ Val.lessdef (sem x y) v.

Theorem eval_addrsymbol:
  forall le id ofs b,
  Genv.find_symbol ge id = Some b ->
  eval_expr ge sp e m le (addrsymbol id ofs) (Vptr b ofs).
Proof.
  intros. unfold addrsymbol. econstructor. constructor. 
  simpl. unfold symbol_address. rewrite H. auto.
Qed.

Theorem eval_addrstack:
  forall le ofs b n,
  sp = Vptr b n ->
  eval_expr ge sp e m le (addrstack ofs) (Vptr b (Int.add n ofs)).
Proof.
  intros. unfold addrstack. econstructor. constructor.
  subst; simpl. auto.
Qed.

Theorem eval_notint: unary_constructor_sound notint Val.notint.
Proof.
  unfold notint; red; intros until x; case (notint_match a); intros; InvEval.
  TrivialExists. 
  subst. TrivialExists. 
  subst. TrivialExists.
  subst. TrivialExists.
  econstructor; split; eauto. 
  eapply eval_Elet. eexact H. 
  eapply eval_Eop.
  eapply eval_Econs. apply eval_Eletvar. simpl. reflexivity.
  eapply eval_Econs. apply eval_Eletvar. simpl. reflexivity.
  apply eval_Enil.  
  simpl. destruct x; simpl; auto. rewrite Int.or_idem. auto.
Qed.

(*
Lemma eval_notbool_base: unary_constructor_sound notbool_base Val.notbool.

  forall le a v b,
  eval_expr ge sp e m le a v ->
  Val.bool_of_val v b ->
  eval_expr ge sp e m le (notbool_base a) (Val.of_bool (negb b)).
Proof. 
  TrivialOp notbool_base. simpl. 
  inv H0. 
  rewrite Int.eq_false; auto.
  rewrite Int.eq_true; auto.
  reflexivity.
Qed.
*)
(*
Hint Resolve Val.bool_of_true_val Val.bool_of_false_val
             Val.bool_of_true_val_inv Val.bool_of_false_val_inv: valboolof.
*)

Theorem eval_notbool: unary_constructor_sound notbool Val.notbool.
Proof.
  assert (DFL: 
    forall le a x,
    eval_expr ge sp e m le a x ->
     exists v, eval_expr ge sp e m le (Eop (Ocmp (Ccompuimm Ceq Int.zero)) (a ::: Enil)) v
           /\ Val.lessdef (Val.notbool x) v).
  intros. TrivialExists. simpl. destruct x; simpl; auto. destruct (Int.eq i Int.zero); auto.

  red. induction a; simpl; intros; eauto. destruct o; eauto.
(* intconst *)
  destruct e0; eauto. InvEval. TrivialExists. simpl. destruct (Int.eq i Int.zero); auto.
(* cmp *)
  inv H. simpl in H5.
  destruct (eval_condition c vl m) as []_eqn. 
  TrivialExists. simpl. rewrite (eval_negate_condition _ _ _ Heqo). destruct b; inv H5; auto.
  inv H5. simpl. 
  destruct (eval_condition (negate_condition c) vl m) as []_eqn.
  destruct b; [exists Vtrue | exists Vfalse]; split; auto; EvalOp; simpl. rewrite Heqo0; auto. rewrite Heqo0; auto.
  exists Vundef; split; auto; EvalOp; simpl. rewrite Heqo0; auto.
(* condition *)
  inv H. destruct v1.
  exploit IHa1; eauto. intros [v [A B]]. exists v; split; auto. eapply eval_Econdition; eauto. 
  exploit IHa2; eauto. intros [v [A B]]. exists v; split; auto. eapply eval_Econdition; eauto. 
Qed.

Theorem eval_addimm:
  forall n, unary_constructor_sound (addimm n) (fun x => Val.add x (Vint n)).
Proof.
  red; unfold addimm; intros until x.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst n. intros. exists x; split; auto. 
  destruct x; simpl; auto. rewrite Int.add_zero. auto. rewrite Int.add_zero. auto.
  case (addimm_match a); intros; InvEval; simpl; TrivialExists; simpl.
  rewrite Int.add_commut. auto.
  unfold symbol_address. destruct (Genv.find_symbol ge s); simpl; auto. rewrite Int.add_commut; auto.
  rewrite Val.add_assoc. rewrite Int.add_commut. auto.
  subst x. rewrite Val.add_assoc. rewrite Int.add_commut. auto.
Qed. 

Theorem eval_add: binary_constructor_sound add Val.add.
Proof.
  red; intros until y.
  unfold add; case (add_match a b); intros; InvEval.
  rewrite Val.add_commut. apply eval_addimm; auto.
  subst. 
  replace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))
     with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).
  apply eval_addimm. EvalOp.
  repeat rewrite Val.add_assoc. decEq. apply Val.add_permut.
  subst. 
  replace (Val.add (Val.add v1 (Vint n1)) y)
     with (Val.add (Val.add v1 y) (Vint n1)).
  apply eval_addimm. EvalOp.
  repeat rewrite Val.add_assoc. decEq. apply Val.add_commut.
  subst. TrivialExists. 
    econstructor. EvalOp. simpl. reflexivity. econstructor. eauto. constructor. 
    simpl. rewrite (Val.add_commut v1). rewrite <- Val.add_assoc. decEq; decEq. 
    unfold symbol_address. destruct (Genv.find_symbol ge s); auto.
  subst. TrivialExists.
    econstructor. EvalOp. simpl. reflexivity. econstructor. eauto. constructor. 
    simpl. repeat rewrite Val.add_assoc. decEq; decEq.
    rewrite Val.add_commut. rewrite Val.add_permut. auto.
  apply eval_addimm; auto.
  subst. rewrite <- Val.add_assoc. apply eval_addimm. EvalOp.
  TrivialExists. 
Qed.

Theorem eval_sub: binary_constructor_sound sub Val.sub.
Proof.
  red; intros until y.
  unfold sub; case (sub_match a b); intros; InvEval.
  rewrite Val.sub_add_opp. apply eval_addimm; auto.
  subst. rewrite Val.sub_add_l. rewrite Val.sub_add_r. 
    rewrite Val.add_assoc. simpl. rewrite Int.add_commut. rewrite <- Int.sub_add_opp.
    apply eval_addimm; EvalOp.
  subst. rewrite Val.sub_add_l. apply eval_addimm; EvalOp.
  subst. rewrite Val.sub_add_r. apply eval_addimm; EvalOp.
  TrivialExists.
Qed.

Lemma eval_rolm:
  forall amount mask,
  unary_constructor_sound (fun a => rolm a amount mask)
                          (fun x => Val.rolm x amount mask).
Proof.
  red; intros until x. unfold rolm; case (rolm_match a); intros; InvEval.
  TrivialExists. 
  subst. rewrite Val.rolm_rolm. TrivialExists.
  subst. rewrite <- Val.rolm_zero. rewrite Val.rolm_rolm.
  rewrite (Int.add_commut Int.zero). rewrite Int.add_zero. TrivialExists.
  TrivialExists.
Qed.

Theorem eval_shlimm:
  forall n, unary_constructor_sound (fun a => shlimm a n)
                                    (fun x => Val.shl x (Vint n)).
Proof.
  red; intros.  unfold shlimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shl_zero; auto.
  destruct (Int.ltu n Int.iwordsize) as []_eqn. 
  rewrite Val.shl_rolm; auto. apply eval_rolm; auto. 
  TrivialExists. econstructor. eauto. econstructor. EvalOp. simpl; eauto. constructor. auto.
Qed.

Theorem eval_shrimm:
  forall n, unary_constructor_sound (fun a => shrimm a n)
                                    (fun x => Val.shr x (Vint n)).
Proof.
  red; intros.  unfold shrimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shr_zero; auto.
  TrivialExists.
Qed.

Theorem eval_shruimm:
  forall n, unary_constructor_sound (fun a => shruimm a n)
                                    (fun x => Val.shru x (Vint n)).
Proof.
  red; intros.  unfold shruimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst. exists x; split; auto. destruct x; simpl; auto. rewrite Int.shru_zero; auto.
  destruct (Int.ltu n Int.iwordsize) as []_eqn. 
  rewrite Val.shru_rolm; auto. apply eval_rolm; auto. 
  TrivialExists. econstructor. eauto. econstructor. EvalOp. simpl; eauto. constructor. auto.
Qed.

(* Move to Values *)

Lemma val_add_lessdef:
  forall v1 v1' v2 v2', Val.lessdef v1 v1' -> Val.lessdef v2 v2' -> Val.lessdef (Val.add v1 v2) (Val.add v1' v2').
Admitted.

Lemma val_lessdef_trans:
  forall v1 v2 v3, Val.lessdef v1 v2 -> Val.lessdef v2 v3 -> Val.lessdef v1 v3.
Proof.
  intros. inv H; auto.
Qed.

Lemma eval_mulimm_base:
  forall n, unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)).
Proof.
  intros; red; intros; unfold mulimm_base. 
  generalize (Int.one_bits_decomp n). 
  generalize (Int.one_bits_range n).
  destruct (Int.one_bits n).
  intros. TrivialExists. 
  destruct l.
  intros. rewrite H1. simpl. 
  rewrite Int.add_zero.
  replace (Vint (Int.shl Int.one i)) with (Val.shl Vone (Vint i)). rewrite Val.shl_mul.
  apply eval_shlimm. auto. simpl. rewrite H0; auto with coqlib.
  destruct l.
  intros. rewrite H1. simpl.
  exploit (eval_shlimm i (x :: le) (Eletvar 0) x). constructor; auto. intros [v1 [A1 B1]].
  exploit (eval_shlimm i0 (x :: le) (Eletvar 0) x). constructor; auto. intros [v2 [A2 B2]].
  exists (Val.add v1 v2); split.
  econstructor. eauto. EvalOp.
  rewrite Int.add_zero.
  replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one i0)))
     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint i0))).
  rewrite Val.mul_add_distr_r.
  repeat rewrite Val.shl_mul. apply val_add_lessdef; auto. 
  simpl. repeat rewrite H0; auto with coqlib. 
  intros. TrivialExists. 
Qed.

Theorem eval_mulimm:
  forall n, unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)).
Proof.
  intros; red; intros until x; unfold mulimm.
  predSpec Int.eq Int.eq_spec n Int.zero. 
  intros. exists (Vint Int.zero); split. EvalOp. 
  destruct x; simpl; auto. subst n. rewrite Int.mul_zero. auto.
  predSpec Int.eq Int.eq_spec n Int.one.
  intros. exists x; split; auto.
  destruct x; simpl; auto. subst n. rewrite Int.mul_one. auto.
  case (mulimm_match a); intros; InvEval.
  TrivialExists. simpl. rewrite Int.mul_commut; auto.
  subst. rewrite Val.mul_add_distr_l. 
  exploit eval_mulimm_base; eauto. instantiate (1 := n). intros [v' [A1 B1]].
  exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v'). auto. intros [v'' [A2 B2]].
  exists v''; split; auto. eapply val_lessdef_trans. eapply val_add_lessdef; eauto. 
  rewrite Val.mul_commut; auto.
  apply eval_mulimm_base; auto.
Qed.

Theorem eval_mul: binary_constructor_sound mul Val.mul.
Proof.
  red; intros until y.
  unfold mul; case (mul_match a b); intros; InvEval.
  rewrite Val.mul_commut. apply eval_mulimm. auto. 
  apply eval_mulimm. auto.
  TrivialExists.
Qed.

Theorem eval_andimm:
  forall n, unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)).
Proof.
  intros; red; intros until x. unfold andimm. case (andimm_match a); intros.
  InvEval. TrivialExists. simpl. rewrite Int.and_commut; auto.
  InvEval. subst. rewrite Val.and_assoc. simpl. rewrite Int.and_commut. TrivialExists. 
  InvEval. subst. TrivialExists. simpl. 
  destruct v1; auto. simpl. unfold Int.rolm. rewrite Int.and_assoc. 
  decEq. decEq. decEq. apply Int.and_commut.
  TrivialExists.
Qed.

Theorem eval_and: binary_constructor_sound and Val.and.
Proof.
  red; intros until y; unfold and; case (and_match a b); intros; InvEval.
  rewrite Val.and_commut. apply eval_andimm; auto.
  apply eval_andimm; auto.
  TrivialExists.
Qed.

Theorem eval_orimm:
  forall n, unary_constructor_sound (orimm n) (fun x => Val.or x (Vint n)).
Proof.
  intros; red; intros until x.
  unfold orimm. destruct (orimm_match a); intros; InvEval.
  TrivialExists. simpl. rewrite Int.or_commut; auto.
  subst. rewrite Val.or_assoc. simpl. rewrite Int.or_commut. TrivialExists. 
  TrivialExists.
Qed.

Remark eval_same_expr:
  forall a1 a2 le v1 v2,
  same_expr_pure a1 a2 = true ->
  eval_expr ge sp e m le a1 v1 ->
  eval_expr ge sp e m le a2 v2 ->
  a1 = a2 /\ v1 = v2.
Proof.
  intros until v2.
  destruct a1; simpl; try (intros; discriminate). 
  destruct a2; simpl; try (intros; discriminate).
  case (ident_eq i i0); intros.
  subst i0. inversion H0. inversion H1. split. auto. congruence. 
  discriminate.
Qed.

Lemma eval_or: binary_constructor_sound or Val.or.
Proof.
  red; intros until y; unfold or; case (or_match a b); intros.
(* rolm - rolm *)
  destruct (Int.eq amount1 amount2 && same_expr_pure t1 t2) as []_eqn.
  destruct (andb_prop _ _ Heqb0).
  generalize (Int.eq_spec amount1 amount2). rewrite H1. intro. subst amount2.
  InvEval. exploit eval_same_expr; eauto. intros [EQ1 EQ2]. subst. 
  rewrite Val.or_rolm. TrivialExists.
  TrivialExists.
(* andimm - rolm *)
  predSpec Int.eq Int.eq_spec mask1 (Int.not mask2). 
  InvEval. subst. TrivialExists. 
  TrivialExists.
(* rolm - andimm *)
  predSpec Int.eq Int.eq_spec mask2 (Int.not mask1). 
  InvEval. subst. rewrite Val.or_commut. TrivialExists.
  TrivialExists.
(* intconst *)
  InvEval. rewrite Val.or_commut. apply eval_orimm; auto. 
  InvEval. apply eval_orimm; auto.
(* default *)
  TrivialExists. 
Qed.

Theorem eval_xorimm:
  forall n, unary_constructor_sound (xorimm n) (fun x => Val.xor x (Vint n)).
Proof.
  intros; red; intros until x.
  unfold xorimm. destruct (xorimm_match a); intros; InvEval.
  TrivialExists. simpl. rewrite Int.xor_commut; auto.
  subst. rewrite Val.xor_assoc. simpl. rewrite Int.xor_commut. TrivialExists. 
  TrivialExists.
Qed.

Theorem eval_xor: binary_constructor_sound xor Val.xor.
Proof.
  red; intros until y; unfold xor; case (xor_match a b); intros; InvEval.
  rewrite Val.xor_commut. apply eval_xorimm; auto.
  apply eval_xorimm; auto.
  TrivialExists.
Qed.

Theorem eval_divs:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divs x y = Some z ->
  exists v, eval_expr ge sp e m le (divs a b) v /\ Val.lessdef z v.
Proof.
  intros. unfold divs. exists z; split. EvalOp. auto.
Qed.

Lemma eval_mod_aux:
  forall divop semdivop,
  (forall sp x y m, eval_operation ge sp divop (x :: y :: nil) m = semdivop x y) ->
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  semdivop x y = Some z ->
  eval_expr ge sp e m le (mod_aux divop a b) (Val.sub x (Val.mul z y)).
Proof.
  intros; unfold mod_aux.
  eapply eval_Elet. eexact H0. eapply eval_Elet. 
  apply eval_lift. eexact H1.
  eapply eval_Eop. eapply eval_Econs. 
  eapply eval_Eletvar. simpl; reflexivity.
  eapply eval_Econs. eapply eval_Eop. 
  eapply eval_Econs. eapply eval_Eop.
  eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity.
  eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity.
  apply eval_Enil.  
  rewrite H. eauto.
  eapply eval_Econs. apply eval_Eletvar. simpl; reflexivity.
  apply eval_Enil.  
  simpl; reflexivity. apply eval_Enil. 
  reflexivity.
Qed.

Theorem val_mods_divs:
  forall x y z, Val.mods x y = Some z -> exists v, Val.divs x y = Some v /\ z = Val.sub x (Val.mul v y).
Proof.
  intros. destruct x; destruct y; simpl in *; try discriminate.
  destruct (Int.eq i0 Int.zero); inv H. 
  exists (Vint (Int.divs i i0)); split; auto. 
  simpl. rewrite Int.mods_divs. auto.
Qed.

Theorem eval_mods:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.mods x y = Some z ->
  exists v, eval_expr ge sp e m le (mods a b) v /\ Val.lessdef z v.
Proof.
  intros; unfold mods. 
  exploit val_mods_divs; eauto. intros [v [A B]].
  subst. econstructor; split; eauto.
  apply eval_mod_aux with (semdivop := Val.divs); auto.
Qed.

(*
Lemma eval_divu_base:
  forall le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divu x y = Some z ->
  exists v, eval_expr ge sp e m le (Eop Odivu (a:::b:::Enil)) v /\ Val.lessdef z v.
Proof.
  intros. unfold divu. exists z; split. EvalOp. auto.
Qed.
*)

Theorem eval_divuimm:
  forall le n a x z,
  eval_expr ge sp e m le a x ->
  Val.divu x (Vint n) = Some z ->
  exists v, eval_expr ge sp e m le (divuimm a n) v /\ Val.lessdef z v.
Proof.
  intros; unfold divuimm. 
  destruct (Int.is_power2 n) as []_eqn. 
  replace z with (Val.shru x (Vint i)). apply eval_shruimm; auto.
  eapply Val.divu_pow2; eauto.
  TrivialExists. 
  econstructor. eauto. econstructor. EvalOp. simpl; eauto. constructor. auto.
Qed.

Theorem eval_divu:
  forall le a x b y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divu x y = Some z ->
  exists v, eval_expr ge sp e m le (divu a b) v /\ Val.lessdef z v.
Proof.
  intros until z. unfold divu; destruct (divu_match b); intros; InvEval.
  eapply eval_divuimm; eauto.
  TrivialExists. 
Qed.

Theorem val_modu_divu:
  forall x y z, Val.modu x y = Some z -> exists v, Val.divu x y = Some v /\ z = Val.sub x (Val.mul v y).
Proof.
  intros. destruct x; destruct y; simpl in *; try discriminate.
  destruct (Int.eq i0 Int.zero) as []_eqn; inv H. 
  exists (Vint (Int.divu i i0)); split; auto. 
  simpl. rewrite Int.modu_divu. auto.
  generalize (Int.eq_spec i0 Int.zero). rewrite Heqb; auto. 
Qed.

Theorem eval_moduimm:
  forall le n a x z,
  eval_expr ge sp e m le a x ->
  Val.modu x (Vint n) = Some z ->
  exists v, eval_expr ge sp e m le (moduimm a n) v /\ Val.lessdef z v.
Proof.
  intros; unfold moduimm. 
  destruct (Int.is_power2 n) as []_eqn. 
  replace z with (Val.and x (Vint (Int.sub n Int.one))). apply eval_andimm; auto.
  eapply Val.modu_pow2; eauto.
  exploit val_modu_divu; eauto. intros [v [A B]].
  subst. econstructor; split; eauto.
  apply eval_mod_aux with (semdivop := Val.divu); auto.
  EvalOp.
Qed.

Theorem eval_modu:
  forall le a x b y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.modu x y = Some z ->
  exists v, eval_expr ge sp e m le (modu a b) v /\ Val.lessdef z v.
Proof.
  intros until y; unfold modu; case (modu_match b); intros; InvEval.
  eapply eval_moduimm; eauto.
  exploit val_modu_divu; eauto. intros [v [A B]].
  subst. econstructor; split; eauto.
  apply eval_mod_aux with (semdivop := Val.divu); auto.
Qed.

Theorem eval_shl: binary_constructor_sound shl Val.shl.
Proof.
  red; intros until y; unfold shl; case (shl_match b); intros.
  InvEval. apply eval_shlimm; auto.
  TrivialExists. 
Qed.

Theorem eval_shr: binary_constructor_sound shr Val.shr.
Proof.
  red; intros until y; unfold shr; case (shr_match b); intros.
  InvEval. apply eval_shrimm; auto.
  TrivialExists. 
Qed.

Theorem eval_shru: binary_constructor_sound shru Val.shru.
Proof.
  red; intros until y; unfold shru; case (shru_match b); intros.
  InvEval. apply eval_shruimm; auto.
  TrivialExists. 
Qed.

Theorem eval_negf: unary_constructor_sound negf Val.negf.
Proof.
  red; intros. TrivialExists. 
Qed.

Theorem eval_absf: unary_constructor_sound absf Val.absf.
Proof.
  red; intros. TrivialExists. 
Qed.

Theorem eval_addf: binary_constructor_sound addf Val.addf.
Proof.
  red; intros until y; unfold addf.
  destruct (use_fused_mul tt); simpl.
  case (addf_match a b); intros; InvEval.
  TrivialExists. simpl. congruence.
  TrivialExists. simpl. rewrite Val.addf_commut. congruence.
  intros. TrivialExists.
  intros. TrivialExists.
Qed.
 
Theorem eval_subf: binary_constructor_sound subf Val.subf.
Proof.
  red; intros until y; unfold subf.
  destruct (use_fused_mul tt); simpl.
  case (subf_match a); intros; InvEval.
  TrivialExists. simpl. congruence.
  TrivialExists.
  intros. TrivialExists.
Qed.

Theorem eval_mulf: binary_constructor_sound mulf Val.mulf.
Proof.
  red; intros; TrivialExists.
Qed.

Theorem eval_divf: binary_constructor_sound divf Val.divf.
Proof.
  red; intros; TrivialExists.
Qed.

Inductive val_lessdef_upto: memory_chunk -> val -> val -> Prop :=
  | val_lessdef_upto_undef: forall chunk v,
      val_lessdef_upto chunk Vundef v
  | val_lessdef_upto_int8: forall n1 n2,
      Int.zero_ext 8 n1 = Int.zero_ext 8 n2 ->
      val_lessdef_upto Mint8unsigned (Vint n1) (Vint n2)
  | val_lessdef_upto_int16: forall n1 n2,
      Int.zero_ext 16 n1 = Int.zero_ext 16 n2 ->
      val_lessdef_upto Mint16unsigned (Vint n1) (Vint n2)
  | val_lessdef_upto_float32: forall f1 f2,
      Float.singleoffloat f1 = Float.singleoffloat f2 ->
      val_lessdef_upto Mfloat32 (Vfloat f1) (Vfloat f2)
  | val_lessdef_upto_refl: forall chunk v,
      val_lessdef_upto chunk v v.

Remark val_lessdef_upto_trans:
  forall chunk v1 v2 v3, val_lessdef_upto chunk v1 v2 -> val_lessdef_upto chunk v2 v3 -> val_lessdef_upto chunk v1 v3.
Proof.
  intros. inv H.
  constructor.
  inv H0. constructor. congruence. constructor. auto.
  inv H0. constructor. congruence. constructor. auto.
  inv H0. constructor. congruence. constructor. auto.
  auto.
Qed.

Lemma eval_uncast_int8:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_int8 a) v /\ val_lessdef_upto Mint8unsigned x v.
Proof.
  intros until a. functional induction (uncast_int8 a); intros.
  (* cast8signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_upto_trans; eauto. 
  subst x. destruct v1; simpl; constructor. apply Int.zero_ext_sign_ext.
  (* cast16signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_upto_trans; eauto.
  subst x. destruct v1; simpl; constructor. admit.
  (* andimm *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_upto_trans; eauto. 
  subst. generalize (Int.eq_spec (Int.and n (Int.repr 255)) (Int.repr 255)); rewrite e2; intro EQ.
  destruct v1; simpl; constructor. 
  repeat rewrite Int.zero_ext_and. rewrite Int.and_assoc. decEq. assumption.
  compute; auto. compute; auto.
  exists x; split; auto. constructor.
  (* default *)
  exists x; split; auto. constructor.
Qed.

Lemma encode_val_lessdef_upto:
  forall chunk v1 v2,
  val_lessdef_upto chunk v1 v2 ->
  list_forall2 (memval_inject inject_id) (encode_val chunk v1) (encode_val chunk v2).
Proof.
  induction 1.
  (* undef *)
  apply encode_val_inject. constructor.
  (* two 8-bits ints *)
  simpl. replace (encode_int Mint8unsigned n2) with (encode_int Mint8unsigned n1). 
  apply inj_bytes_inject.
  rewrite <- (encode_int8_zero_ext n1). 
  rewrite <- (encode_int8_zero_ext n2).
  congruence.
  (* two 16-bits ints *)
  simpl. replace (encode_int Mint16unsigned n2) with (encode_int Mint16unsigned n1). 
  apply inj_bytes_inject.
  rewrite <- (encode_int16_zero_ext n1). 
  rewrite <- (encode_int16_zero_ext n2).
  congruence.
  (* two single floats *)
  simpl. replace (encode_float Mfloat32 f2) with (encode_float Mfloat32 f1). 
  apply inj_bytes_inject.
  unfold encode_float. 
  rewrite <- (Float.bits_of_singleoffloat f1).
  rewrite <- (Float.bits_of_singleoffloat f2).
  congruence.
  (* same values *)
  apply encode_val_inject. rewrite val_inject_id. auto.
Qed.

Lemma eval_uncast:
  forall le chunk b ofs a x m1,
  eval_expr ge sp e m le a x ->
  Mem.store chunk m b ofs x = Some m1 ->
  exists v, exists m2,
     eval_expr ge sp e m le (uncast chunk a) v
  /\ Mem.store chunk m b ofs v = Some m2
  /\ Mem.extends m1 m2.
Proof.
  
val_lessdef_upto Mint8unsigned x v.




Inductive val_lessdef_int (n: Z): val -> val -> Prop :=
  | val_lessdef_int_undef: forall v, val_lessdef_int n Vundef v
  | val_lessdef_int_int: forall n1 n2, Int.zero_ext n n1 = Int.zero_ext n n2 -> val_lessdef_int n (Vint n1) (Vint n2)
  | val_lessdef_int_refl: forall v, val_lessdef_int n v v.
(*
Definition val_lessdef_int_N (n: Z) (v1 v2: val): Prop :=
  match v1, v2 with
  | Vundef, _ => True
  | Vint n1, Vint n2 => Int.zero_ext n n1 = Int.zero_ext n n2
  | _, _ => v1 = v2
  end.
*)
Remark val_lessdef_int_trans:
  forall n v1 v2 v3, val_lessdef_int n v1 v2 -> val_lessdef_int n v2 v3 -> val_lessdef_int n v1 v3.
Proof.
  intros. inv H.
  constructor.
  inv H0. constructor. congruence. constructor. auto.
  auto.
Qed.

Lemma eval_uncast_int8:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_int8 a) v /\ val_lessdef_int 8 x v.
Proof.
  intros until a. functional induction (uncast_int8 a); intros.
  (* cast8signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_int_trans; eauto. 
  subst x. destruct v1; simpl; constructor. apply Int.zero_ext_sign_ext.
  (* cast16signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_int_trans; eauto.
  subst x. destruct v1; simpl; constructor. admit.
  (* andimm *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply val_lessdef_int_trans; eauto. 
  subst. generalize (Int.eq_spec (Int.and n (Int.repr 255)) (Int.repr 255)); rewrite e2; intro EQ.
  destruct v1; simpl; constructor. 
  repeat rewrite Int.zero_ext_and. rewrite Int.and_assoc. decEq. assumption.
  compute; auto. compute; auto.
  exists x; split; auto. constructor.
  (* default *)
  exists x; split; auto. constructor.
Qed.

Remark memval_lessdef_trans:
  forall v1 v2 v3, memval_lessdef v1 v2 -> memval_lessdef v2 v3 -> memval_lessdef v1 v3.
Proof.
  intros. inv H. auto. unfold inject_id in H1. inv H1. rewrite Int.add_zero in H0. auto. constructor.
Qed.

Definition memvals_lessdef (vl1 vl2: list memval) : Prop :=
  list_forall2 memval_lessdef vl1 vl2.

Remark memvals_lessdef_refl:
  forall vl, memvals_lessdef vl vl.
Proof.
  induction vl; constructor; auto. apply memval_lessdef_refl.
Qed.

Remark memvals_lessdef_trans:
  forall vl1 vl2, memvals_lessdef vl1 vl2 -> forall vl3, memvals_lessdef vl2 vl3 -> memvals_lessdef vl1 vl3.
Proof.
  induction 1; intros. inv H. constructor. 
  inv H1. constructor. eapply memval_lessdef_trans; eauto. eapply IHlist_forall2; eauto.
Qed.

Remark memvals_lessdef_encode_val:
  forall chunk v1 v2,
  Val.lessdef v1 v2 ->
  memvals_lessdef (encode_val chunk v1) (encode_val chunk v2).
Proof.
  intros. apply encode_val_inject. rewrite val_inject_id. auto.
Qed.

Lemma foo:
  forall v1 v2,
  val_lessdef_int 8 v1 v2 -> memvals_lessdef (encode_val Mint8unsigned v1) (encode_val Mint8unsigned v2).
Proof.
  induction 1.
  (* undef *)
  apply encode_val_inject. constructor.
  (* two ints *)
  simpl. replace (encode_int Mint8unsigned n2) with (encode_int Mint8unsigned n1). 
  apply inj_bytes_inject.
  rewrite <- (encode_int8_zero_ext n1). 
  rewrite <- (encode_int8_zero_ext n2).
  congruence.
  (* same values *)
  apply encode_val_inject. rewrite val_inject_id. auto.
Qed.

  replace (encode_val Mint8unsigned Vundef) with (list_repeat (List.length (encode_val Mint8unsigned v)) Undef).
  apply repeat_U
  simpl. 




Lemma eval_uncast_int8:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_int8 a) v /\ 
            memvals_lessdef (encode_val Mint8unsigned x) (encode_val Mint8unsigned v).
Proof.
  intros until a. functional induction (uncast_int8 a); intros.
  (* cast8signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply memvals_lessdef_trans; eauto. subst x. 
  destruct v1; simpl Val.sign_ext; try (apply memvals_lessdef_encode_val; auto; fail).
  simpl. repeat rewrite <- encode_int8_signed_unsigned. 
  rewrite encode_int8_sign_ext. apply memvals_lessdef_refl.
  (* cast16signed *)
  InvEval. exploit IHe0; eauto. intros [v [A B]]. exists v; split; auto.
  eapply memvals_lessdef_trans; eauto. subst x. 
  destruct v1; simpl Val.sign_ext; try (apply memvals_lessdef_encode_val; auto; fail).
  simpl. repeat rewrite <- encode_int8_signed_unsigned. 
  rewrite encode_int8_sign_ext. apply memvals_lessdef_refl.

encode_change (encode_int Mint8unsrewrite encode_int8_sign_ext. 

 replace (encode_val Mint8unsigned x) with (encode_val Mint8unsigned v1). eauto.
  subst. destruct v1; simpl Val.sign_ext. ; auto. rewrite Int.zero_ext_sign_ext; auto. 
  (* cast16signed *)
  InvEval. replace (Val.zero_ext 8 x) with (Val.zero_ext 8 v1). eauto. 
  subst. destruct v1; simpl; auto. decEq. 
  admit.
  (* andimm *)
  InvEval. replace (Val.zero_ext 8 x) with (Val.zero_ext 8 v1). eauto.
  subst. generalize (Int.eq_spec (Int.and n (Int.repr 255)) (Int.repr 255)); rewrite e2; intro EQ.
  destruct v1; simpl; auto. decEq. 
  repeat rewrite Int.zero_ext_and. rewrite Int.and_assoc. decEq. symmetry. assumption.
  compute; auto. compute; auto.
  exists x; auto. 
  (* default *)
  exists x; auto.
Qed.


Lemma eval_uncast_int8:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_int8 a) v /\ Val.lessdef (Val.zero_ext 8 x) (Val.zero_ext 8 v).
Proof.
  intros until a. functional induction (uncast_int8 a); intros.
  (* cast8signed *)
  InvEval. replace (Val.zero_ext 8 x) with (Val.zero_ext 8 v1). eauto. 
  subst. destruct v1; simpl; auto. rewrite Int.zero_ext_sign_ext; auto. 
  (* cast16signed *)
  InvEval. replace (Val.zero_ext 8 x) with (Val.zero_ext 8 v1). eauto. 
  subst. destruct v1; simpl; auto. decEq. 
  admit.
  (* andimm *)
  InvEval. replace (Val.zero_ext 8 x) with (Val.zero_ext 8 v1). eauto.
  subst. generalize (Int.eq_spec (Int.and n (Int.repr 255)) (Int.repr 255)); rewrite e2; intro EQ.
  destruct v1; simpl; auto. decEq. 
  repeat rewrite Int.zero_ext_and. rewrite Int.and_assoc. decEq. symmetry. assumption.
  compute; auto. compute; auto.
  exists x; auto. 
  (* default *)
  exists x; auto.
Qed.

Lemma eval_uncast_int16:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_int16 a) v /\ Val.lessdef (Val.zero_ext 16 x) (Val.zero_ext 16 v).
Proof.
  intros until a. functional induction (uncast_int16 a); intros.
  (* cast16signed *)
  InvEval. replace (Val.zero_ext 16 x) with (Val.zero_ext 16 v1). eauto. 
  subst. destruct v1; simpl; auto. rewrite Int.zero_ext_sign_ext; auto. 
  (* andimm *)
  InvEval. replace (Val.zero_ext 16 x) with (Val.zero_ext 16 v1). eauto.
  subst. generalize (Int.eq_spec (Int.and n (Int.repr 65535)) (Int.repr 65535)); rewrite e2; intro EQ.
  destruct v1; simpl; auto. decEq. 
  repeat rewrite Int.zero_ext_and. rewrite Int.and_assoc. decEq. symmetry. assumption.
  compute; auto. compute; auto.
  exists x; auto. 
  (* default *)
  exists x; auto.
Qed.

Lemma eval_uncast_float32:
  forall le a x,
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (uncast_float32 a) v /\ Val.lessdef (Val.singleoffloat x) (Val.singleoffloat v).
Proof.
  intros until a. functional induction (uncast_float32 a); intros.
  (* cast16signed *)
  InvEval. replace (Val.singleoffloat x) with (Val.singleoffloat v1). eauto. 
  subst. destruct v1; simpl; auto. rewrite Float.singleoffloat_idem. auto.
  (* default *)
  exists x; auto.
Qed.

(* Move elsewhere *)

Remark repeat_Undef_inject_encode_int:
  forall f n chunk i,
  size_chunk_nat chunk = n ->
  list_forall2 (memval_inject f) (list_repeat n Undef) (inj_bytes (encode_int chunk i)).
Proof.
  intros. replace n with (List.length (inj_bytes (encode_int chunk i))).
  apply repeat_Undef_inject_any. rewrite length_inj_bytes. rewrite encode_int_length. auto.
Qed.
 
Remark repeat_Undef_inject_encode_float:
  forall f n chunk i,
  size_chunk_nat chunk = n ->
  list_forall2 (memval_inject f) (list_repeat n Undef) (inj_bytes (encode_float chunk i)).
Proof.
  intros. replace n with (List.length (inj_bytes (encode_float chunk i))).
  apply repeat_Undef_inject_any. rewrite length_inj_bytes. rewrite encode_float_length. auto.
Qed.

Remark val_inject_int:
  forall f x y, val_inject f (Vint x) (Vint y) -> x = y.
Proof.
  intros. inv H; auto. 
Qed.

Remark val_inject_float:
  forall f x y, val_inject f (Vfloat x) (Vfloat y) -> x = y.
Proof.
  intros. inv H; auto. 
Qed.

Ltac SolveIt :=
  match goal with
  | [ |- list_forall2 (memval_inject ?f) (Undef :: ?l) (Undef :: _) ] =>
      exact (repeat_Undef_inject_self f (List.length (Undef :: l)))
  | [ |- list_forall2 (memval_inject ?f) (Undef :: ?l) (inj_bytes (encode_int _ _)) ] =>
      apply (repeat_Undef_inject_encode_int f (List.length (Undef :: l))); reflexivity
  | [ |- list_forall2 (memval_inject ?f) (Undef :: ?l) (inj_bytes (encode_float _ _)) ] =>
      apply (repeat_Undef_inject_encode_float f (List.length (Undef :: l))); reflexivity
  | [ H: val_inject _ _ Vundef |- _ ] => inversion H
  | [ H: val_inject _ (Vint _) (Vint _) |- _ ] => generalize (val_inject_int _ _ _ H); intro
  | [ H: val_inject _ (Vfloat _) _ |- _ ] => generalize (val_inject_float _ _ _ H); intro
  | _ => idtac
  end.

Lemma encode_val_inject_gen:
  forall f chunk v1 v2,
  val_inject f (Val.load_result chunk v1) (Val.load_result chunk v2) ->
  list_forall2 (memval_inject f) (encode_val chunk v1) (encode_val chunk v2).
Proof.
  intros. unfold Val.load_result in H. destruct chunk; destruct v1; destruct v2; simpl; SolveIt.
Focus 2.

  inv H.
Opaque Int.sign_ext. 
  inv H. admit.


; simpl in H; inv H.

apply (repeat_Undef_inject_enco


  repeat constructor.
  


  eapply repeat_Undef_inject_any. 
  repeat constructor. 

Lemma encode_val_load_result:
  forall chunk v, encode_val chunk (Val.load_result chunk v) = encode_val chunk v.
Proof.
  intros. destruct chunk; destruct v; simpl; auto.
Focus 2.
  unfold encode_float. simpl. unfold rev_if_be. 

Theorem eval_store_uncast:
  forall chunk b ofs m' le a x,
  eval_expr ge sp e m le a x ->
  Mem.store chunk m b ofs x = Some m' ->
  exists v, exists m'',
     eval_expr ge sp e m le (uncast chunk a) v
  /\ Mem.store chunk m b ofs v = Some m''
  /\ Mem.extends m' m''.
Proof.
  intros. destruct chunk; simpl uncast.
(* int8signed *)
  exploit eval_uncast_int8; eauto. intros [v [A B]].
  
  




  
  rewrite Int.and_assoc. 
  transitivity (Int.zero_ext 8 (Int.zero_ext 16 (Int.sign_ext 16 i))).
  rewrite Int.zero_ext_widen. 

 rewrite Int.zero_ext_sign_ext; auto. 

exploit IHe0; eauto. intros [v [A B]]. 
  destruct e0. InvEval. destruct e1; InvEval. 
  exploit 
[idtac | InvEval ]. InvEval.  

Theorem eval_cast8signed: unary_constructor_sound cast8signed (Val.sign_ext 8).

Theorem eval_cast8unsigned: unary_constructor_sound cast8unsigned (Val.zero_ext 8).

Theorem eval_cast16signed: unary_constructor_sound cast16signed (Val.sign_ext 16).

Theorem eval_cast16unsigned: unary_constructor_sound cast16unsigned (Val.zero_ext 16).

Theorem eval_singleoffloat: unary_constructor_sound singleoffloat Val.singleoffloat.

Theorem eval_comp:
  forall le c a x b y,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le b (Vint y) ->
  eval_expr ge sp e m le (comp c a b) (Val.of_bool(Int.cmp c x y)).
Proof.
  intros until y.
  unfold comp; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. rewrite Int.swap_cmp. destruct (Int.cmp c x y); reflexivity.
  EvalOp. simpl. destruct (Int.cmp c x y); reflexivity.
  EvalOp. simpl. destruct (Int.cmp c x y); reflexivity.
Qed.

Theorem eval_compu_int:
  forall le c a x b y,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le b (Vint y) ->
  eval_expr ge sp e m le (compu c a b) (Val.of_bool(Int.cmpu c x y)).
Proof.
  intros until y.
  unfold compu; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. rewrite Int.swap_cmpu. destruct (Int.cmpu c x y); reflexivity.
  EvalOp. simpl. destruct (Int.cmpu c x y); reflexivity.
  EvalOp. simpl. destruct (Int.cmpu c x y); reflexivity.
Qed.

Remark eval_compare_null_transf:
  forall c x v,
  Cminor.eval_compare_null c x = Some v ->
  match eval_compare_null c x with
  | Some true => Some Vtrue
  | Some false => Some Vfalse
  | None => None (A:=val)
  end = Some v.
Proof.
  unfold Cminor.eval_compare_null, eval_compare_null; intros.
  destruct (Int.eq x Int.zero); try discriminate. 
  destruct c; try discriminate; auto.
Qed.

Theorem eval_compu_ptr_int:
  forall le c a x1 x2 b y v,
  eval_expr ge sp e m le a (Vptr x1 x2) ->
  eval_expr ge sp e m le b (Vint y) ->
  Cminor.eval_compare_null c y = Some v ->
  eval_expr ge sp e m le (compu c a b) v.
Proof.
  intros until v.
  unfold compu; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. apply eval_compare_null_transf; auto.
  EvalOp. simpl. apply eval_compare_null_transf; auto.
Qed.

Remark eval_compare_null_swap:
  forall c x,
  Cminor.eval_compare_null (swap_comparison c) x = 
  Cminor.eval_compare_null c x.
Proof.
  intros. unfold Cminor.eval_compare_null. 
  destruct (Int.eq x Int.zero). destruct c; auto. auto.
Qed.

Theorem eval_compu_int_ptr:
  forall le c a x b y1 y2 v,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le b (Vptr y1 y2) ->
  Cminor.eval_compare_null c x = Some v ->
  eval_expr ge sp e m le (compu c a b) v.
Proof.
  intros until v.
  unfold compu; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. apply eval_compare_null_transf. 
  rewrite eval_compare_null_swap; auto.
  EvalOp. simpl. apply eval_compare_null_transf. auto.
Qed.

Theorem eval_compu_ptr_ptr:
  forall le c a x1 x2 b y1 y2,
  eval_expr ge sp e m le a (Vptr x1 x2) ->
  eval_expr ge sp e m le b (Vptr y1 y2) ->
  Mem.valid_pointer m x1 (Int.unsigned x2)
  && Mem.valid_pointer m y1 (Int.unsigned y2) = true ->
  x1 = y1 ->
  eval_expr ge sp e m le (compu c a b) (Val.of_bool(Int.cmpu c x2 y2)).
Proof.
  intros until y2.
  unfold compu; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. rewrite H1. subst y1. rewrite dec_eq_true. 
  destruct (Int.cmpu c x2 y2); reflexivity.
Qed.

Theorem eval_compu_ptr_ptr_2:
  forall le c a x1 x2 b y1 y2 v,
  eval_expr ge sp e m le a (Vptr x1 x2) ->
  eval_expr ge sp e m le b (Vptr y1 y2) ->
  Mem.valid_pointer m x1 (Int.unsigned x2)
  && Mem.valid_pointer m y1 (Int.unsigned y2) = true ->
  x1 <> y1 ->
  Cminor.eval_compare_mismatch c = Some v ->
  eval_expr ge sp e m le (compu c a b) v.
Proof.
  intros until y2.
  unfold compu; case (comp_match a b); intros; InvEval.
  EvalOp. simpl. rewrite H1. rewrite dec_eq_false; auto.
  destruct c; simpl in H3; inv H3; auto.
Qed.

Theorem eval_compf:
  forall le c a x b y,
  eval_expr ge sp e m le a (Vfloat x) ->
  eval_expr ge sp e m le b (Vfloat y) ->
  eval_expr ge sp e m le (compf c a b) (Val.of_bool(Float.cmp c x y)).
Proof.
  intros. unfold compf. EvalOp. simpl. 
  destruct (Float.cmp c x y); reflexivity.
Qed.

Theorem eval_negint:
  forall le a x,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le (negint a) (Vint (Int.neg x)).
Proof. intros; unfold negint; EvalOp. Qed.

Theorem eval_negf:
  forall le a x,
  eval_expr ge sp e m le a (Vfloat x) ->
  eval_expr ge sp e m le (negf a) (Vfloat (Float.neg x)).
Proof. intros; unfold negf; EvalOp. Qed.

Theorem eval_absf:
  forall le a x,
  eval_expr ge sp e m le a (Vfloat x) ->
  eval_expr ge sp e m le (absf a) (Vfloat (Float.abs x)).
Proof. intros; unfold absf; EvalOp. Qed.

Theorem eval_intoffloat:
  forall le a x n,
  eval_expr ge sp e m le a (Vfloat x) ->
  Float.intoffloat x = Some n ->
  eval_expr ge sp e m le (intoffloat a) (Vint n).
Proof.
  intros; unfold intoffloat; EvalOp. simpl. rewrite H0; auto.
Qed.

Theorem eval_intuoffloat:
  forall le a x n,
  eval_expr ge sp e m le a (Vfloat x) ->
  Float.intuoffloat x = Some n ->
  eval_expr ge sp e m le (intuoffloat a) (Vint n).
Proof.
  intros. unfold intuoffloat. 
  econstructor. eauto. 
  set (im := Int.repr Int.half_modulus).
  set (fm := Float.floatofintu im).
  assert (eval_expr ge sp e m (Vfloat x :: le) (Eletvar O) (Vfloat x)).
    constructor. auto. 
  apply eval_Econdition with (v1 := Float.cmp Clt x fm).
  econstructor. constructor. eauto. constructor. EvalOp. simpl; eauto. constructor.
  simpl. auto.
  caseEq (Float.cmp Clt x fm); intros.
  exploit Float.intuoffloat_intoffloat_1; eauto. intro EQ.
  EvalOp. simpl. rewrite EQ; auto.
  exploit Float.intuoffloat_intoffloat_2; eauto. intro EQ.
  replace n with (Int.add (Int.sub n Float.ox8000_0000) Float.ox8000_0000).
  apply eval_addimm. eapply eval_intoffloat; eauto.
  apply eval_subf; auto. EvalOp.
  rewrite Int.sub_add_opp. rewrite Int.add_assoc. apply Int.add_zero. 
Qed.

Theorem eval_floatofint:
  forall le a x,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le (floatofint a) (Vfloat (Float.floatofint x)).
Proof.
  intros. unfold floatofint. rewrite Float.floatofint_from_words.
  apply eval_subf.
  EvalOp. constructor. EvalOp. simpl; eauto.
  constructor. apply eval_addimm. eauto. constructor.
  simpl. auto. 
  EvalOp. 
Qed.

Theorem eval_floatofintu:
  forall le a x,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le (floatofintu a) (Vfloat (Float.floatofintu x)).
Proof.
  intros. unfold floatofintu. rewrite Float.floatofintu_from_words.
  apply eval_subf.
  EvalOp. constructor. EvalOp. simpl; eauto.
  constructor. eauto. constructor.
  simpl. auto. 
  EvalOp. 
Qed.

Theorem eval_xor:
  forall le a x b y,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le b (Vint y) ->
  eval_expr ge sp e m le (xor a b) (Vint (Int.xor x y)).
Proof. intros; unfold xor; EvalOp. Qed.

Theorem eval_shr:
  forall le a x b y,
  eval_expr ge sp e m le a (Vint x) ->
  eval_expr ge sp e m le b (Vint y) ->
  Int.ltu y Int.iwordsize = true ->
  eval_expr ge sp e m le (shr a b) (Vint (Int.shr x y)).
Proof. intros; unfold shr; EvalOp. simpl. rewrite H1. auto. Qed.

Theorem eval_mulf:
  forall le a x b y,
  eval_expr ge sp e m le a (Vfloat x) ->
  eval_expr ge sp e m le b (Vfloat y) ->
  eval_expr ge sp e m le (mulf a b) (Vfloat (Float.mul x y)).
Proof. intros; unfold mulf; EvalOp. Qed.

Theorem eval_divf:
  forall le a x b y,
  eval_expr ge sp e m le a (Vfloat x) ->
  eval_expr ge sp e m le b (Vfloat y) ->
  eval_expr ge sp e m le (divf a b) (Vfloat (Float.div x y)).
Proof. intros; unfold divf; EvalOp. Qed.

Theorem eval_addressing:
  forall le chunk a v b ofs,
  eval_expr ge sp e m le a v ->
  v = Vptr b ofs ->
  match addressing chunk a with (mode, args) =>
    exists vl,
    eval_exprlist ge sp e m le args vl /\ 
    eval_addressing ge sp mode vl = Some v
  end.
Proof.
  intros until v. unfold addressing; case (addressing_match a); intros; InvEval.
  exists (@nil val). split. eauto with evalexpr. simpl. auto.
  exists (@nil val). split. eauto with evalexpr. simpl. auto.
  destruct (Genv.find_symbol ge s); congruence.
  exists (Vint i0 :: nil). split. eauto with evalexpr. 
    simpl. destruct (Genv.find_symbol ge s). congruence. discriminate.
  exists (Vptr b0 i :: nil). split. eauto with evalexpr. 
    simpl. congruence.
  exists (Vint i :: Vptr b0 i0 :: nil).
    split. eauto with evalexpr. simpl. 
    congruence.
  exists (Vptr b0 i :: Vint i0 :: nil).
    split. eauto with evalexpr. simpl. congruence.
  exists (v :: nil). split. eauto with evalexpr. 
    subst v. simpl. rewrite Int.add_zero. auto.
Qed.

End CMCONSTR.

